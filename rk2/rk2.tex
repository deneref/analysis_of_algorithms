\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
%\usepackage[14pt]{extsizes}
\usepackage{listings}

% Для листинга кода:
\lstset{ %
language=go,                 % выбор языка для подсветки 
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках            
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\#*}{*)}   % если нужно добавить комментарии в коде
}

% Для измененных титулов глав:
\usepackage{titlesec, blindtext, color} % подключаем нужные пакеты
\definecolor{gray75}{gray}{0.75} % определяем цвет
\newcommand{\hsp}{\hspace{20pt}} % длина линии в 20pt
% titleformat определяет стиль
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}

\usepackage{amsmath}
\usepackage{mathptmx}
% plot
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage{amsmath}
\usepackage{tikz,pgfplots}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\usepackage{graphicx}
\graphicspath{{src/}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}

\begin{document}
%\def\chaptername{} % убирает "Глава"
\begin{titlepage}
	\centering
	{\scshape\LARGE МГТУ им. Баумана \par}
	\vspace{3cm}
	{\scshape\Large Рубежный контроль №2\par}
	\vspace{0.5cm}	
	{\scshape\Large По курсу: "Анализ алгоритмов"\par}
	\vspace{1.5cm}
	{\huge\bfseries Регулярные выражения \par}
	\vspace{2cm}
	\Large Работу выполнил: Мокеев Даниил, ИУ7-54\par
	\vspace{0.5cm}
	\Large Преподаватели:  Волкова Л.Л., Строганов Ю.В.\par

	\vfill
	\large \textit {Москва, 2019} \par
\end{titlepage}

\tableofcontents

\newpage
\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}

Цель работы: изучение возможности регулярных выражений. Реализация поиска по тексу при использовании регулярных выражений и конечного автомата.
В ходе рубежного контроля предстоит:
\begin{itemize}
	\item Изучить регулярные выражения; 
	\item реализовать поиск по тексту всех вхожедний цикла for с помощью регулярных выражений и конечного автомата.
\end{itemize}

\chapter{Аналитическая часть}
Регулярные выражения (англ. regular expressions) — формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов (символов-джокеров, англ. wildcard characters). Для поиска используется строка-образец (англ. pattern, по-русски её часто называют «шаблоном», «маской»), состоящая из символов и метасимволов и задающая правило поиска. Для манипуляций с текстом дополнительно задаётся строка замены, которая также может содержать в себе специальные символы.


\section{Использование регулярных выражений}
Регулярные выражения используются некоторыми текстовыми редакторами и утилитами для поиска и подстановки текста. Например, при помощи регулярных выражений можно задать шаблоны, позволяющие:
\begin{itemize}
	\item найти все последовательности символов «кот» в любом контексте, как то: «кот», «котлета», «терракотовый»;
	\item найти отдельно стоящее слово «кот» и заменить его на «кошка»;
	\item найти слово «кот», которому предшествует слово «персидский» или «чеширский»;
	\item убрать из текста все предложения, в которых упоминается слово кот или кошка.
\end{itemize}
Регулярные выражения позволяют задавать и гораздо более сложные шаблоны поиска или замены.

Результатом работы с регулярным выражением может быть:
\begin{itemize}
	\item проверка наличия искомого образца в заданном тексте;
	\item определение подстроки текста, которая сопоставляется образцу;
	\item определение групп символов, соответствующих отдельным частям образца.
\end{itemize}
Если регулярное выражение используется для замены текста, то результатом работы будет новая текстовая строка, представляющая из себя исходный текст, из которого удалены найденные подстроки (сопоставленные образцу), а вместо них подставлены строки замены (возможно, модифицированные запомненными при разборе группами символов из исходного текста). Частным случаем модификации текста является удаление всех вхождений найденного образца — для чего строка замены указывается пустой.
\section{Регулярные выражения в теории формальных языков}
Регулярные выражения состоят из констант и операторов, которые определяют множества строк и множества операций на них соответственно. Определены следующие константы:
\begin{itemize}
\item (пустое множество) $\emptyset$.
\item (пустая строка) $\epsilon$ обозначает строку, не содержащую ни одного символа; эквивалентно \"".
\item (символьный литерал) "a", где a — символ используемого алфавита.
\item (множество) из символов, либо из других множеств.
и следующие операции:
\end{itemize}
\begin{itemize}
	\item (сцепление, конкатенация) RS обозначает множество ${\alpha\beta | \alpha \in R  \& \beta \in S}$. Например, \{"boy", "girl"\}\{"friend", "cott"\} = \{"boyfriend", "girlfriend", "boycott", "girlcott"\}.
	\item(дизъюнкция, чередование) $R|S$ обозначает объединение R и S. Например, \{"ab", "c"\}|\{"ab", "d", "ef"\} = \{"ab", "c", "d", "ef"\}.
	\item(замыкание Клини, звезда Клини) R* обозначает минимальное надмножество множества R, которое содержит $\epsilon$ и замкнуто относительно конкатенации. Это есть множество всех строк, полученных конкатенацией нуля или более строк из R. Например, \{"Run", "Forrest"\}* = \{$\epsilon$, "Run", "Forrest", "RunRun", "RunForrest", "ForrestRun", "ForrestForrest", "RunRunRun",
	
	 "RunRunForrest", "RunForrestRun", \}.
	\item Регулярные выражения, входящие в современные языки программирования (в частности, PCRE), имеют больше возможностей, чем то, что называется регулярными выражениями в теории формальных языков; в частности, в них есть нумерованные обратные ссылки. Это позволяет им разбирать строки, описываемые не только регулярными грамматиками, но и более сложными, в частности, контекстно-свободными грамматиками.
\end{itemize}
\section{Вывод}
Были рассмотренны регулярныные выражения и их обоснование в теории формальных языков.

\chapter{Конструкторская часть}
\textbf{Требования к вводу:}
На вход подаются две матрицы
\newline
\textbf{Требования к программе:}
\begin{itemize}
	\item корректное умножение двух матриц;
	\item при матрицах неправильных размеров программа не должна аварийно завершаться.
\end{itemize}



\section{Вывод}
В данном разделе была рассмотрена схема алгоритма Винограда и способ ее распараллеливания.

\chapter{Технологическая часть}
\section{Выбор ЯП}
Я выбрал в качестве языка программирования Golang, потому как он достаточно удобен, быстр и успешно использует концепции мультипоточного программирования.

Время работы алгоритмов было замерено с помощью функции Now() из библиотеки time.

\section{Описание структуры ПО}
В данном разделе будет представленна функциональная схема программы (Рис. 3.1.)

\section{Сведения о модулях программы}


\section{Листинг кода алгоритмов}
В данном разделе будет представлен листинги кода алгоритма Винограда (3.1), распараллеленого алгоритма Винограда (3.2)
\begin{lstlisting}[label=CodeStand,caption = Алгоритм Винограда]
func winograd(mtr1, mtr2 *mtr) *mtr{
	if mtr2.rows != mtr1.cols{
		panic("Wrong size of matrix")
	}
	row1 := mtr1.rows; col1 := mtr1.cols
	row2:= mtr2.rows; col2 := mtr2.cols

	row_factor := make([]int, row1, row1)
	col_factor := make([]int, col2, col2)

	for i:=0; i<row1;i++{
		for j:=0;j<col1 / 2;j++{
			row_factor[i] += mtr1.buff[i][2*j] * mtr1.buff[i][2*j+1]
	}}
	
	for i:=0; i<col2;i++{
		for j:=0;j<row2 / 2;j++{
			col_factor[i] += mtr2.buff[2*j][i]*mtr2.buff[2*j+1][i]
	}}

		answer := new_mtr(row1, col2)

	for i:=0;i<row1;i++{
		for j:=0;j<col2;j++{
			answer.buff[i][j]+= - row_factor[i] - col_factor[j]
			for k:=0;k<col1 / 2;k++{
				answer.buff[i][j] += ((mtr1.buff[i][2 * k] + mtr2.buff[2 * k + 1][j]) * (mtr1.buff[i][2 * k + 1] + mtr2.buff[2 * k][j]))
	}}}

	if (row2 % 2) != 0{
		for i:=0;i<row1;i++{
			for j:=0;j<col2;j++{
				answer.buff[i][j] += mtr1.buff[i][col1 - 1] * mtr2.buff[col1 - 1][j]
	}}}
	return answer
}
\end{lstlisting}

\begin{lstlisting}[label=winograd_mult,caption=Распараллеленый Алгоритм Винограда]
func winograd_parallel(mtr1, mtr2 *mtr, threads int) *mtr{
	if mtr2.rows != mtr1.cols{
		panic("Wrong size of matrix")
	}
	row1 := mtr1.rows; col1 := mtr1.cols
	row2:= mtr2.rows; col2 := mtr2.cols

	row_factor := make([]int, row1, row1)
	col_factor := make([]int, col2, col2)

	for i:=0; i<row1;i++{
		for j:=0;j<col1 / 2;j++{
			row_factor[i] += mtr1.buff[i][2*j] * mtr1.buff[i][2*j+1]
	}}
	for i:=0; i<col2;i++{
		for j:=0;j<row2 / 2;j++{
			col_factor[i] += mtr2.buff[2*j][i]*mtr2.buff[2*j+1][i]
	}}
	answer := new_mtr(row1, col2)
	in := make(chan int); quit := make(chan bool)
	mult := func(){
		for{
			select {
				case i := <- in:
					for j:=0;j<col2;j++{
					answer.buff[i][j]+= - row_factor[i] - col_factor[j]
					for k:=0;k<col1 / 2;k++{
					answer.buff[i][j] += ((mtr1.buff[i][2 * k] + mtr2.buff[2 * k + 1][j]) * (mtr1.buff[i][2 * k + 1] + mtr2.buff[2 * k][j]))
					}}
			case <- quit:
				return
			}
		}
	}
	for i:=0;i<threads;i++{
		go mult()
	}
	for i:=0;i<mtr1.rows;i++{
		in <- i
	}
	for i:= 0 ; i<threads; i++{
		quit<-true
	}
	return answer
}
\end{lstlisting}


\section{Вывод}
В данном разделе была рассмотрена структура ПО и листинги кода программы.

\chapter{Исследовательская часть}
Был проведен замер времени работы алгоритмов с использованием разного колличества потоков.
Исследования были проведены на процессоре Intel Core i5-6200U
\section{Примеры работы}
В данном разделе приведен пример работы программы (Рис. 4.1)

\section{Постановка эксперемента}
Проведем сравнение для каждого из алгоритмов. Для замера времени будем использовать функцию time.Now()

Сравним результаты для обычного Винограда и Винограда с распараллеленным главным циклом:
\newpage

\newpage
\subsection{Вывод эксперементальной части}
Экперемент показывает, что использование одного потока эквивалентно обычной версии алгоритма. Использование двух потоков значительно ускоряет работу алгоритма. Данный эффект наблюдается и при увеличении числа потоков, однако при использовании более четырех потоков дальнейшего ускорения не происходит.
\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение}
В ходе лабораторной работы были изучены возможности параллельных вычислений, реализован алгоритм Винограда умножения матриц
с помощью параллельных вычислений.

Было произведено сравнение работы обычного алгоритма Винограда и параллельной реализации при увеличении количества потоков. Выяснилось, что увеличение потоков до 4х сокращает время работы на 70\% по сравнению с
однопоточной реализацией. Однако дальнейшее увеличение количества потоков не дает значительного выигрыша во времени (разница менее 1\%). 

\addcontentsline{toc}{chapter}{Список литературы}
\begin{thebibliography}{3}
	\bibitem{Fridl}
	Фридл, Дж. Регулярные выражения = Mastering Regular Expressions. — СПб.: «Питер», 2001. — 352 с. — (Библиотека программиста). — ISBN 5-318-00056-8.
	\bibitem{Smith}
	Смит, Билл. Методы и алгоритмы вычислений на строках (regexp) = Computing Patterns in Strings. — М.: «Вильямс», 2006. — 496 с. — ISBN 0-201-39839-7.
	\bibitem{Fort}
	Форта, Бен. Освой самостоятельно регулярные выражения. 10 минут на урок = Sams Teach Yourself Regular Expressions in 10 Minutes. — М.: «Вильямс», 2005. — 184 с. — ISBN 5-8459-0713-6.
\end{thebibliography}

\end{document}

